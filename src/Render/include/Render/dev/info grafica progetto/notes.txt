
/*
 * Cool way to get the string version of a type: Take the stringified version of a function, functionality given 
 * by any compiler.
 * Such function is templetised by your target type, and therefore in the stringified representation by the 
 * compiler will appear somewhere.
 * Filter out the function name plus any prefixes and suffixes added by your compiler and you have the typename
 */
template<typename Type>
[[nodiscard]] constexpr auto stripped_type_name() noexcept {
#if defined ENTT_PRETTY_FUNCTION
    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
    auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
    auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
    return value;
#else
    return std::string_view{""};
#endif
}


